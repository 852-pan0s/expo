{"version":3,"file":"AppAuth.js","sourceRoot":"","sources":["../src/AppAuth.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  AuthorizationNotifier,\n  AuthorizationRequest,\n  AuthorizationResponse,\n  TokenResponse,\n  StringMap,\n} from '@openid/appauth';\nimport invariant from 'invariant';\n\nimport { ExpoAccessTokenRequest, ExpoAccessTokenRequestJson } from './ExpoAccessTokenRequest';\nimport { ExpoAuthorizationRequest } from './ExpoAuthorizationRequest';\nimport {\n  ExpoAuthorizationServiceConfiguration,\n  ExpoAuthorizationServiceConfigurationJson,\n} from './ExpoAuthorizationServiceConfiguration';\nimport { ExpoRefreshTokenRequest, ExpoRefreshTokenRequestJson } from './ExpoRefreshTokenRequest';\nimport {\n  ExpoRegistrationHandler,\n  ExpoRegistrationRequest,\n  ExpoRegistrationRequestJson,\n  ExpoRegistrationResponse,\n} from './ExpoRegistrationHandler';\nimport { ExpoRequestHandler } from './ExpoRequestHandler';\nimport { ExpoRevokeTokenRequest, ExpoRevokeTokenRequestJson } from './ExpoRevokeTokenRequest';\nimport { ExpoTokenRequestHandler } from './ExpoTokenRequestHandler';\n\ntype IssuerOrServiceConfig =\n  | string\n  | ExpoAuthorizationServiceConfiguration\n  | ExpoAuthorizationServiceConfigurationJson;\n\n/**\n * Utility method for resolving the service config\n *\n * @param issuerOrServiceConfig\n */\nasync function serviceConfigFromPropsAsync(\n  issuerOrServiceConfig: IssuerOrServiceConfig\n): Promise<ExpoAuthorizationServiceConfiguration> {\n  invariant(issuerOrServiceConfig, 'Expected a valid service configuration or issuer URL');\n  if (typeof issuerOrServiceConfig === 'string') {\n    return await ExpoAuthorizationServiceConfiguration.fetchFromIssuer(issuerOrServiceConfig);\n  } else if (issuerOrServiceConfig.constructor.name === 'ExpoAuthorizationServiceConfiguration') {\n    return issuerOrServiceConfig as ExpoAuthorizationServiceConfiguration;\n  }\n  return new ExpoAuthorizationServiceConfiguration(issuerOrServiceConfig);\n}\n\n/**\n * Wrap the browser API and make it more node friendly.\n *\n * @param props\n */\nexport async function authAsync(\n  request: ExpoAuthorizationRequest,\n  issuerOrServiceConfig: IssuerOrServiceConfig\n): Promise<TokenResponse | AuthorizationResponse> {\n  // Eval early\n  await request.toJson();\n\n  // Get the service config\n  const config = await serviceConfigFromPropsAsync(issuerOrServiceConfig);\n  const authResponse = await authRequestAsync(request, config);\n  console.log(`Authorization Code ${authResponse.response.code}`);\n  // inspects response and processes further if needed (e.g. authorization\n  // code exchange)\n  if (request.responseType === AuthorizationRequest.RESPONSE_TYPE_CODE) {\n    // If the request is for the code flow (NB. not hybrid), then assume the\n    // code is intended for this client, and perform the authorization\n    // code exchange.\n    return await exchangeAsync(\n      {\n        clientId: request.clientId,\n        redirectUri: request.redirectUri,\n        code: authResponse.response.code,\n        clientSecret: authResponse.request?.extras?.client_secret,\n        codeVerifier: authResponse.request?.internal?.code_verifier,\n      },\n      config\n    );\n  }\n  // Hybrid flow (code id_token).\n  // Two possible cases:\n  // 1. The code is not for this client, ie. will be sent to a\n  //    web service that performs the ID token verification and token\n  //    exchange.\n  // 2. The code is for this client and, for security reasons, the\n  //    application developer must verify the id_token signature and\n  //    c_hash before calling the token endpoint.\n  return authResponse.response;\n}\n\n/**\n * Make an auth request that returns the auth code which can be exchanged for an access token.\n *\n * @param props\n * @param issuerOrServiceConfig\n */\nexport async function authRequestAsync(\n  request: ExpoAuthorizationRequest,\n  issuerOrServiceConfig: IssuerOrServiceConfig\n): Promise<{ request: AuthorizationRequest; response: AuthorizationResponse }> {\n  invariant(\n    request.redirectUri,\n    `\\`ExpoAuthorizationRequest\\` requires a valid \\`redirectUri\\`. Example: 'com.your.app:/oauthredirect'`\n  );\n  // Get the service config\n  const config = await serviceConfigFromPropsAsync(issuerOrServiceConfig);\n\n  return new Promise(async (resolve, reject) => {\n    const notifier = new AuthorizationNotifier();\n    const authorizationHandler = new ExpoRequestHandler();\n    // set notifier to deliver responses\n    authorizationHandler.setAuthorizationNotifier(notifier);\n    // set a listener to listen for authorization responses\n    notifier.setAuthorizationListener(async (_, response, error) => {\n      if (response) {\n        resolve({ request, response });\n      } else {\n        reject(error);\n      }\n    });\n\n    // Make the authorization request (launch the external web browser).\n    authorizationHandler.performAuthorizationRequest(config, request);\n    // Complete the request.\n    // This resolves the promise and invokes the authorization listener we defined earlier.\n    authorizationHandler.completeAuthorizationRequestIfPossible();\n  });\n}\n\nexport async function exchangeAsync(\n  props: ExpoAccessTokenRequestJson,\n  issuerOrServiceConfig: IssuerOrServiceConfig\n): Promise<TokenResponse> {\n  invariant(\n    props.redirectUri,\n    `\\`ExpoAccessTokenRequest\\` requires a valid \\`redirectUri\\`. Example: 'com.your.app:/oauthredirect'`\n  );\n  // use the code to make the token request.\n  /**\n   * If this fails (status 400), it's either because the PKCE code is wrong, or because too many params are being passed in the body:\n   * If you get the error `invalid_grant` please refer to https://www.oauth.com/oauth2-servers/pkce/authorization-code-exchange/\n   *\n   * grant_type=authorization_code\n   * redirect_uri=''\n   * code=''\n   * code_verifier=''\n   */\n  const request = new ExpoAccessTokenRequest(props);\n  const handler = new ExpoTokenRequestHandler();\n  const config = await serviceConfigFromPropsAsync(issuerOrServiceConfig);\n  const response = await handler.performTokenRequest(config, request);\n  return response;\n}\n\nexport async function refreshAsync(\n  props: ExpoRefreshTokenRequestJson,\n  issuerOrServiceConfig: IssuerOrServiceConfig\n): Promise<TokenResponse> {\n  invariant(props.refreshToken, `\\`ExpoRefreshTokenRequest\\` requires a valid \\`refreshToken\\`.`);\n  const request = new ExpoRefreshTokenRequest(props);\n  const handler = new ExpoTokenRequestHandler();\n  const config = await serviceConfigFromPropsAsync(issuerOrServiceConfig);\n  const response = await handler.performTokenRequest(config, request);\n\n  // Custom: reuse the refresh token if one wasn't returned\n  response.refreshToken = response.refreshToken || props.refreshToken;\n\n  return response;\n}\n\nexport async function registerAsync(\n  props: ExpoRegistrationRequestJson,\n  issuerOrServiceConfig: IssuerOrServiceConfig\n): Promise<ExpoRegistrationResponse> {\n  const request = new ExpoRegistrationRequest(props);\n  const handler = new ExpoRegistrationHandler();\n  const config = await serviceConfigFromPropsAsync(issuerOrServiceConfig);\n  const response = await handler.performRegistrationRequest(config, request);\n  return response;\n}\n\nexport async function revokeAsync(\n  props: ExpoRevokeTokenRequestJson,\n  issuerOrServiceConfig: IssuerOrServiceConfig\n): Promise<any> {\n  const request = new ExpoRevokeTokenRequest(props);\n  const handler = new ExpoTokenRequestHandler();\n  const config = await serviceConfigFromPropsAsync(issuerOrServiceConfig);\n  const response = await handler.performRevokeTokenRequest(config, request);\n  return response;\n}\n"]}